{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE FlexibleInstances  #-}
{-# LANGUAGE NoImplicitPrelude  #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings  #-}

module Main where

import           Control.Monad        (replicateM)
import           Plutus.Model         (Run,
                                       TypedValidator (TypedValidator), DatumMode (HashDatum),
                                       adaValue, defaultBabbage, mustFail, testNoErrors, sendValue,
                                       toV2, FakeCoin (FakeCoin), fakeValue, userSpend, Tx, UserSpend, spendScript, payToScript,
                                       payToKey, submitTx, validateIn, utxoAt, newUser, ada, Ada (Lovelace), spend, withSpend, currentTimeRad)
import           Plutus.V2.Ledger.Api (BuiltinData, PubKeyHash, Value, TxOutRef, txOutValue)
import           PlutusTx.Prelude     (($))
import           PlutusTx.Builtins    (Integer, mkConstr)
--import           PlutusTx.Builtins.Internal 
--import           PlutusTx.Builtins.Class (fromBuiltin)
import           Prelude              (IO, (.), (<>), undefined, mconcat, take)
import qualified ExploitableSwap      as OnChain
import           Test.Tasty           (defaultMain, testGroup)

---------------------------------------------------------------------------------------------------
------------------------------------------ TESTING ------------------------------------------------

main :: IO ()
main = do
  defaultMain $ do
    testGroup
      "Catch double spend with testing"
      [ good "Normal spending" (normalSpending 100)
      , bad  "Double spending" (doubleSpending 100)
      ]
 where
    bad msg = good msg . mustFail
    good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage

---------------------------------------------------------------------------------------------------
----------------------------- HELPER FUNCTIONS/INSTANCES/TYPES ------------------------------------

scToken :: FakeCoin
scToken = FakeCoin "Super-Cool-Token"
 
type HomeworkScript = TypedValidator OnChain.DatumSwap ()

swapScript :: HomeworkScript
swapScript = TypedValidator $ toV2 OnChain.validator

lockingTx :: PubKeyHash -> Integer -> UserSpend -> Value -> Tx
lockingTx pkh price usp val =
  mconcat
    [ userSpend usp,
      payToScript swapScript (HashDatum (OnChain.DatumSwap pkh price)) val
    ]

consumingTx :: PubKeyHash -> Integer  -> PubKeyHash -> PubKeyHash -> UserSpend -> TxOutRef -> Value -> Tx 
consumingTx pkh price beneficiary user usp ref val =
  mconcat
    [ userSpend usp
    , spendScript swapScript ref () (OnChain.DatumSwap pkh price) 
    , payToKey user val
    , payToKey beneficiary (adaValue price)
    ]


doubleConsumingTx :: PubKeyHash -> Integer -> PubKeyHash -> PubKeyHash -> UserSpend -> TxOutRef -> Value -> TxOutRef -> Value -> Tx
doubleConsumingTx pkh price beneficiary user usp ref1 val1 ref2 val2 =
  mconcat
    [ userSpend usp
    , spendScript swapScript ref1 () (OnChain.DatumSwap pkh price) 
    , spendScript swapScript ref2 () (OnChain.DatumSwap pkh price) 
    , payToKey user val1
    , payToKey user val2
    , payToKey beneficiary (adaValue price)
    ]

---------------------------------------------------------------------------------------------------
-------------------------------------- TESTING SPENDING -------------------------------------------



normalSpending :: Integer -> Run ()
normalSpending price = do 
  -- Setup Users
  let valueNT = fakeValue scToken 1
  user1 <- newUser (adaValue 10000 <> valueNT)
  user2 <- newUser $ adaValue 10000
  sp <- spend user1 valueNT
  submitTx user1 $ lockingTx user1 price sp valueNT

  let valAda = adaValue 100
  utxos <- utxoAt swapScript
  let [(ref, out)] = utxos
  sp <- spend user2 valAda
  ct <- currentTimeRad 100
  tx <- validateIn ct $ consumingTx user1 price user1 user2 sp ref (txOutValue out)
  submitTx user2 tx


doubleSpending :: Integer -> Run ()
doubleSpending price = do 
  -- Setup Users
  let valueNT = fakeValue scToken 1
  user1 <- newUser (adaValue 10000 <> valueNT <> valueNT)
  user2 <- newUser $ adaValue 10000
  sp1 <- spend user1 valueNT
  submitTx user1 $ (lockingTx user1 price sp1 valueNT) 
  sp2 <- spend user1 valueNT
  submitTx user1 $ (lockingTx user1 price sp2 valueNT) 
  
  let valAda = adaValue 100
  utxos <- utxoAt swapScript
  let [(ref1, out1),(ref2, out2)] = utxos
  sp3 <- spend user2 valAda
  ct <- currentTimeRad 100
  tx <- validateIn ct $ doubleConsumingTx user1 price user1 user2 sp3 ref1 (txOutValue out1) ref2 (txOutValue out2)
  submitTx user2 tx